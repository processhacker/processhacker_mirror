== Building ==
Process Hacker must be built using a Microsoft C compiler. 
Do not attempt to use any other compiler or be prepared to 
spend a long time trying to fix things. The only tested 
IDE is Visual Studio 2008. Visual C++ 2008 Express Edition 
may or may not work. It is recommended that the x64 compiler 
be installed even if you are not intending to build for that 
platform.

== Code structure ==
There are multiple modules; each .c file can contain one or 
more modules. There are multiple modules in each abstraction 
layer, and there is generally a .h file for each abstraction 
layer.

Abstraction layers and their modules:

* Base (base.h)

* PH Base (phbase.h)
  * NT definitions and imports (ntimport.h, ntimport.c)
  * Object manager (ref.h, ref.c)
  * Fast resource lock (fastlock.h, fastlock.c)
  * Queued resource lock (queuedlock.h, queuedlock.c)
  * Base support (basesup.c)
    * Heap
    * Mutex
    * Event
    * Rundown Protection
    * String
    * ANSI String
    * String Builder
    * List
    * Pointer List
    * Queue
    * Hashtable
    * Callback
    * Callback Sync
  * Base support with auto-dereference support (basesupa.c)
    * String
  * Work Queue (workqueue.c)

* PH (ph.h)
  * KProcessHacker (kph.h, kph.c)
  * NT object support (native.c)
  * LSA support (lsa.c)
  * Mapped images (mapimg.c)
  * Handle information (hndlinfo.c)
  * Image verification (verify.c)
  * Provider (provider.c)
  * Symbol provider (symprv.c)
  * Process provider (procprv.c)
  * Service provider (srvprv.c)
  * Module provider (modprv.c)
  * Thread provider (thrdprv.c)
  * Handle provider (hndlprv.c)
  * General support (support.c)

* PH GUI (phgui.h)
  * Main (main.c)
  * GUI support (guisup.c)
    * List view
    * Tab control
    * Menu
    * Layout manager
  * Settings (settings.h, settings.c)
  * Main window (mainwnd.c)
  * Process properties (procprp.c)
  * Security editor (secedit.c)
  * Object security data (secdata.c)
  * UI actions (actions.c)
  * ...

== Conventions ==

==== Names ====
  * Functions, function parameters, and global variables use CamelCase.
  * Local variables use lowerCamelCase.
  * Structs, enums and unions use CAPS_WITH_UNDERSCORES.

All names must have an appropriate prefix (with some exceptions):
  * "Ph" or "PH_" (structures) for public names.
  * "Php" or "PHP_" for private names.
  * Some variants such as "Pha".
  * Fastcall functions have "f" appended to the prefix. E.g.
    "Ph" -> "Phf", "Php" -> "Phpf".
  * Private prefixes are created by appending "p" to the prefix. E.g. 
    "Ph" -> "Php", "Pha" -> "Phap".
  * Functions and global variables without a prefix must be declared 
    "static".
    * "static" names must have a private prefix.
    * Names with a private prefix do not have to be "static".
  * Structures without a prefix must be declared in a ".c" file. 
    Structures declared in a ".c" file may or may not have a prefix.

==== Types ====
Unless used for the Win32 API, the standard types are:

 * BOOLEAN for a 1 byte boolean, or LOGICAL for a 4 byte boolean.
 * UCHAR for 1 byte.
 * SHORT/USHORT for 2 bytes.
 * LONG/ULONG for 4 bytes.
 * LONG64/ULONG64 for 8 bytes.
 * CHAR for a 1 byte character.
 * WCHAR for a 2 byte character.
 * PSTR for a string of 1 byte characters.
 * PWSTR for a string of 2 byte characters.

====== Booleans ======
Always use:

    if (booleanVariable) // not "if (booleanVariable == TRUE)"
    {
        ...
    }

to test a boolean value.

==== Annotations, qualifiers ====
 * All parameters must use annotations, such as __in, __inout, __out, etc. 
 * Do not use "const".
 * Do not use "volatile" in definitions. Instead, cast to a volatile 
   pointer when necessary.

==== Function success indicators ====
There are three main types of indicators used:

 * A NTSTATUS value is returned. The NT_SUCCESS macro checks 
   if a status value indicates success.
 * A BOOLEAN value is returned. TRUE indicates success.
 * The result of the function is returned (e.g. a pointer). 
   A special value (e.g. NULL) indicates failure.

Unless indicated, a function which fails is guaranteed not to 
modify any of its output parameters (__out, __out_opt, etc.).

For functions which are passed a callback function, it is not 
guaranteed that a failed function has not executed the callback 
function.

==== Threads ====
Every thread start routine must have the following signature:

    NTSTATUS NameOfRoutine(
        __in PVOID Parameter
        );

Thread creation is done through the PhCreateThread function.

==== Synchronization ====
The queued lock should be used for all synchronization, due to its 
small size and good performance. The *Fast variants of the acquire/release 
functions should be used whenever possible, because they make 
non-contended acquires up to twice as fast. Although the queued lock 
is a reader-writer lock, it can be used as a mutex simply by using 
the exclusive acquire/release functions.

For mutexes with blocking expected, the PH_MUTEX is an alternative. 
Currently the PH_MUTEX is the same as RTL_CRITICAL_SECTION.

Events can be used through PH_EVENT. This object does not create a 
kernel event object until needed, and testing its state is very 
fast.

Rundown protection is available through PH_RUNDOWN_PROTECT.

Condition variables are available using the queued lock. Simply 
declare and initialize a queued lock variable, and use the 
PhPulse(All)Condition and PhWaitForCondition functions.

==== Memory management ====
Use PhAllocate/PhFree to allocate/free memory. For complex objects, 
use the reference counting system.

There is semi-automatic reference counting available in the form 
of auto-dereference pools (similar to Apple's NSAutoreleasePools). 
Use the PhaDereferenceObject to add an object to the thread's pool, 
and the object will be dereferenced at an unspecified time in the 
future. However, the object is guaranteed to not be dereferenced 
while the current function is executing.

The inline function PHA_DEREFERENCE takes a pointer to an object, 
auto-dereferences it, and returns the pointer.

Referencing an object is necessary whenever a pointer to the object 
is stored in a globally visible location or passed to another thread. 
In most other cases, referencing is not necessary.

All objects passed to functions must have a guaranteed reference 
for the duration of that call. One mistake is to keep a reference 
which could be destroyed in a window procedure, and to use that reference 
implicitly inside the window procedure. Messages can still be pumped 
(e.g. dialog boxes) while the window procedure is executing, so the 
window procedure must reference the object as soon as possible.

==== Strings ====
Strings use the PH_STRING type, managed by reference counting. 
To create a string object from a null-terminated string:

    PPH_STRING myString = PhCreateString(L"My string");

    wprintf(
        L"My string is \"%s\", and uses %u bytes.\n",
        myString->Buffer,
        myString->Length
        );

All string objects have an embedded length (always in bytes), 
and the string is additionally null-terminated for compatibility 
reasons.

String objects must be treated as immutable unless a string 
object is created and modified before the pointer is shared with 
any other functions or stored in any global variables.

Strings can be concatenated with PhConcatStrings:

    PPH_STRING newString;
    
    newString = PhConcatStrings(
        4,
        L"My first string, ",
        L"My second string, ",
        aStringFromSomewhere,
        L"My fourth string."
        );

Another version concatenates two strings:

    PPH_STRING newString;
    
    newString = PhConcatStrings2(
        L"My first string, ",
        L"My second string."
        );

Strings can be formatted:

    PPH_STRING newString;
    
    newString = PhFormatString(
        L"%d: %s, %#x",
        100,
        L"test",
        0xff
        );

==== Tips ====
 * Use !! to "cast" to a boolean.